{"version":3,"file":"CustomPlugin.js","mappings":"CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,IACQ,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,eAAgB,GAAIH,GACD,iBAAZC,QACdA,QAAsB,aAAID,IAE1BD,EAAmB,aAAIC,IARzB,CASGK,MAAM,WACT,M,8VCVqBC,EAAAA,SAAAA,GACjB,WAAYC,EAAOC,I,4FAAe,e,iKAAA,wDACxBD,EAAOC,IADiB,OAE9B,EAAKD,MAAQA,EACb,EAAKE,QAAU,EACf,EAAKC,WAAa,IAClB,EAAKC,UAAY,EACjB,EAAKC,WAAa,KAClB,EAAKC,QAAS,EAPgB,E,mUADIC,OAAOC,QAAQC,a,kCAc9BC,KAAKC,QAAQC,OACnBC,GAAG,SAAUH,KAAKI,OAAQJ,MACvCA,KAAKK,KAAOL,KAAKV,MAAMgB,IAAID,KAAK,IAAK,IAAK,SAAU,CAChDE,WAAY,QACZC,SAAU,GACVC,MAAO,c,iEA0BLC,EAAMC,M,6BAGTD,EAAMC,GACJX,KAAKJ,SAGLI,KAAKN,WAAaiB,GAAS,MACtBX,KAAKR,QAAU,KACjBQ,KAAKR,QAAU,GAEnBQ,KAAKK,KAAKO,QAAQZ,KAAKR,SACvBQ,KAAKN,UAAYM,KAAKP,c,iCAKnBiB,EAAMC,M,wMAmBbX,KAAKa,WACLb,KAAKV,WAAQwB,I,+BAIRC,GACLf,KAAKP,WAAasB,I,8BAKlBf,KAAKR,QAAU,EACfQ,KAAKK,KAAKO,QAAQ,O,EA7FLvB,G,UAAAA,G","sources":["webpack://CustomPlugin/webpack/universalModuleDefinition","webpack://CustomPlugin/./main.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"CustomPlugin\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"CustomPlugin\"] = factory();\n\telse\n\t\troot[\"CustomPlugin\"] = factory();\n})(self, function() {\nreturn ","export default class CustomPlugin extends Phaser.Plugins.ScenePlugin {\n    constructor(scene, pluginManager) {\n        super(scene, pluginManager);\n        this.scene = scene;\n        this.counter = 0;\n        this.countDelay = 300;\n        this.nextCount = 0;\n        this.textObject = null;\n        this.active = true;\n    }\n\n    //  Called when the Plugin is booted by the PluginManager.\n    //  If you need to reference other systems in the Scene (like the Loader or DisplayList) then set-up those references now, not in the constructor.\n    boot() {\n        let eventEmitter = this.systems.events;\n        eventEmitter.on('update', this.update, this);\n        this.text = this.scene.add.text(100, 200, 'Phaser', {\n            fontFamily: 'Arial',\n            fontSize: 64,\n            color: '#00ff00'\n        });\n\n        /*\n            List of unused eventEmitters to activate matching methods of this plugin\n        */\n\n        //eventEmitter.on('start', this.start, this);\n\n        //eventEmitter.on('preupdate', this.preUpdate, this);\n        //eventEmitter.on('postupdate', this.postUpdate, this);\n\n        //eventEmitter.on('pause', this.pause, this);\n        //eventEmitter.on('resume', this.resume, this);\n\n        //eventEmitter.on('sleep', this.sleep, this);\n        //eventEmitter.on('wake', this.wake, this);\n\n        //eventEmitter.on('shutdown', this.shutdown, this);\n        //eventEmitter.on('destroy', this.destroy, this);*/\n    }\n\n    //  Called when a Scene is started by the SceneManager. The Scene is now active, visible and running.\n    start() {}\n\n    //  Called every Scene step - phase 1\n    preUpdate(time, delta) {}\n\n    //  Called every Scene step - phase 2\n    update(time, delta) {\n        if (!this.active) {\n            return;\n        }\n        if ((this.nextCount -= delta) < 0) {\n            if (++this.counter > 99) {\n                this.counter = 0;\n            }\n            this.text.setText(this.counter);\n            this.nextCount = this.countDelay;\n        }\n    }\n\n    //  Called every Scene step - phase 3\n    postUpdate(time, delta) {}\n\n    //  Called when a Scene is paused. A paused scene doesn't have its Step run, but still renders.\n    pause() {}\n\n    //  Called when a Scene is resumed from a paused state.\n    resume() {}\n\n    //  Called when a Scene is put to sleep. A sleeping scene doesn't update or render, but isn't destroyed or shutdown. preUpdate events still fire.\n    sleep() {}\n\n    //  Called when a Scene is woken from a sleeping state.\n    wake() {}\n\n    //  Called when a Scene shuts down, it may then come back again later (which will invoke the 'start' event) but should be considered dormant.\n    shutdown() {}\n\n    //  Called when a Scene is destroyed by the Scene Manager. There is no coming back from a destroyed Scene, so clear up all resources here.\n    destroy() {\n        this.shutdown();\n        this.scene = undefined;\n    }\n\n    //  Custom method for this plugin\n    setDelay(delay) {\n        this.countDelay = delay;\n    }\n\n    //  Custom method for this plugin\n    reset() {\n        this.counter = 0;\n        this.text.setText(0);\n    }\n}\n"],"names":["root","factory","exports","module","define","amd","self","CustomPlugin","scene","pluginManager","counter","countDelay","nextCount","textObject","active","Phaser","Plugins","ScenePlugin","this","systems","events","on","update","text","add","fontFamily","fontSize","color","time","delta","setText","shutdown","undefined","delay"],"sourceRoot":""}